#!/bin/ash

# Displays info on storage devices in the system

VER=1.7.1
VERDATE="2013-12-20"

. tss__common

get_device_info () {
	PTTYPE="MBR"
	tss_file_tool gpt /dev/$1 | grep -q "yes" && PTTYPE="GPT"
	PTTYPE="${CWHT}[$CBLU$PTTYPE${CWHT}]"
	REM="$(cat /sys/block/$1/removable | tr -d '\n')"
	readlink "/sys/block/$1" | grep -q "/usb" && USB=1 || USB=0
	case $REM$USB in
		00) TYPE="Internal " ;;
		01) TYPE="USB HDD  " ;;
		10) TYPE="Removable" ;;
		11) TYPE="USB disk " ;;
		*)  TYPE="Type err?" ;;
	esac
	Z=$(cat /sys/block/$1/size)
	if [ -e /sys/block/$1/device/model ]
		then MODEL=$(cat /sys/block/$1/device/model)
		DSN=$(hdparm -I /dev/$1 2>/dev/null | grep 'Serial Number:' | sed 's/[^:]*[^a-zA-Z0-9]*//;s/ *$//g')
		else MODEL="(No model)"
	fi
	DEVSIZE=$(expr $Z / 2 \* 1024 / 1000000000)
	if [ "$DEVSIZE" -lt "9" ]
		then DEVSIZE="$(expr $Z / 2 \* 1024 / 1000000) MB"
		else if [ "$DEVSIZE" -gt 999 ]
			then DEVSIZE="$(expr $Z / 2 \* 1024 / 100000000000 | sed 's/\(.\)\(.\)/\1.\2/') TB"
			else DEVSIZE="$DEVSIZE GB"
		fi
	fi
	# Auto-space device size string length
	LEN=$(echo "$DEVSIZE" | wc -c); LEN=$((8 - LEN))
	while [ $LEN -gt 0 ]; do DEVSIZE=" $DEVSIZE"; LEN=$((LEN - 1)); done
	unset LEN MDTYPE
	if [ -e /sys/block/$1/md/level ]
		then
		MDTYPE="Linux software $(cat /sys/block/$1/md/level)"
		MEMBERS="$(echo /sys/block/$1/slaves/* | sed "s#/sys/block/$1/slaves/##g")"
	fi
	unset ATTRIBS
	echo "$KILL" | grep -q "$1" && ATTRIBS="${CWHT}[Linux RAID slave]$COFF "
	echo "$MOUNTED" | grep -q "/dev/$1 " && ATTRIBS="$ATTRIBS${CYEL}[Mounted]$COFF "
}

expand_fsid () {
	case $1 in
		#--------MBR types--------
		 4)   FS="FAT16       " ;;
		 6)   FS="FAT16       " ;;
		 7)   FS="NTFS        " ;;
		 b)   FS="FAT32       " ;;
		 c)   FS="FAT32       " ;;
		 e)   FS="FAT16       " ;;
		27)   FS="Acer Rec    " ;;
		81)   FS="Minix       " ;;
		82)   FS="Linux swap  " ;;
		83)   FS="Linux       " ;;
		86)   FS="Win RAID    " ;;
		87)   FS="Win RAID    " ;;
		8e)   FS="Linux LVM   " ;;
		de)   FS="Dell Diags  " ;;
		ee)   FS="EFI GPT     " ;;
		ef)   FS="EFT FAT     " ;;
		fd)   FS="Linux RAID  " ;;
		#--------GPT types--------
		0700) FS="Windows data" ;;
		0c01) FS="MS reserved " ;;
		8200) FS="Linux swap  " ;;
		8300) FS="Linux FS    " ;;
		8e00) FS="Linux LVM   " ;;
		ab00) FS="Apple boot  " ;;
		af00) FS="Apple HFS(+)" ;;
		af01) FS="Apple RAID  " ;;
		ef00) FS="EFI system  " ;;
		ef01) FS="MBR part    " ;;
		ef02) FS="BIOS boot   " ;;
		fd00) FS="Linux RAID  " ;;
		*)    FS="Unknown     " ;;
	esac
}

# If "nopart" is passed, only display devices.
NP=0
if [ "$1" = "nopart" ]
	then NP=1
fi

if [ "$NP" = "0" ]
	then echo -n "${CWHT}Tritech filesystem info tool, version "
	echo "$CCYA$VER$CWHT, last updated $CPUR$VERDATE$COFF"
fi

if [ -e /sbin/fdisk ]; then FDISK=/sbin/fdisk; fi
if [ -e /usr/sbin/fdisk ]; then FDISK=/usr/sbin/fdisk; fi
if [ -e /sbin/sgdisk ]; then SGDISK=/sbin/sgdisk; fi
if [ -e /usr/sbin/sgdisk ]; then SGDISK=/usr/sbin/sgdisk; fi

PART=$(mktemp)
rm -f $PART
DRIVES="$(echo /dev/sd? /dev/hd? | tr ' ' '\n' | grep -v '\?' | sort)"
# Pulls partition info via fdisk and adds lines to PART
# in the format:  /dev/devX=type.size_in_1k_blocks
for DRIVE in $DRIVES
	do if tss_file_tool gpt $DRIVE | grep -q "no"
		then $FDISK -l $DRIVE 2>/dev/null | grep /dev | \
			grep -v Disk | tr -d \* | tr -d + | \
			awk '{ print $1"="$5"."$4 }' >> $PART
		else $SGDISK -p $DRIVE 2>/dev/null | grep '^   ' | \
			sed 's/  */ /g;s/^ //g' | while read LINE
			do
			HWSS1=$(cat /sys/block/$(basename $DRIVE)/queue/hw_sector_size)
			HWSS2=$(expr $HWSS1 / 1024)
			PS=$(echo $LINE | cut -d" " -f2)
			PE=$(echo $LINE | cut -d" " -f3)
			PSIZE=$(expr $PE - $PS)
			if [ $HWSS1 -eq 512 ]
				then PSIZE=$(expr $PSIZE / 2)
				else PSIZE=$(expr $PSIZE \* $HWSS2)a
			fi
			PN=$(echo $LINE | cut -d" " -f1)
			PT=$(echo $LINE | cut -d" " -f6)
			echo "$DRIVE$PN=$PT.$PSIZE" >> $PART
		done
	fi
done

KILL="$(echo /sys/block/md*/slaves/* | tr ' ' '\n' | grep -v '\*' | sed 's#.*/##g' | tr '\n' ' ')"

for X in $(echo /dev/md?* | tr ' ' '\n' | grep -v '\?' | sed s#/dev/##g | tr '\n' ' ')
	do test "$(cat /sys/block/$X/size)" != "0" && RAID="$RAID $X"
done

MOUNTED="$(cut -d" " -f1 < /proc/mounts | grep '^/' | sort | uniq | tr \\n ' ') "
ROOTMT=$(mountpoint -d /)
if [ $(echo $ROOTMT | sed 's/:.*//') -gt 0 ]
	then for X in /sys/block/*/dev
		do grep -q "$ROOTMT" $X && MOUNTED="$MOUNTED $(echo $X | sed 's#/sys/block/\(.*\)/dev#/dev/\1#') "
	done
fi

DRV="none"

test ! -e $PART && echo "${CRED}No disks found. Aborting.$COFF" && exit 1

for DRV in $DRIVES
	do NPT=1; NPD=0; X=$(echo "$DRV" | sed s./dev/..) 
	# If no partition 1-4 exists, don't display partitions
	for C in 1 2 3 4
		do test -e "/sys/block/$X/$X$C" && NPT=0
	done
	test "$NP" = "1" && NPT=1
	get_device_info $X
	if [ "$DEVSIZE" != "0 MB" ]
		then unset DSN2
		test -n "$DSN" && DSN2=" $COFF($DSN) "
		echo -en "$CPUR$X: $CGRN$DEVSIZE  $CWHT$PTTYPE  $CRED$TYPE $CCYA$MODEL$DSN2 $CWHT$ATTRIBS$COFF"
		if [[ "$NP" = "0" && "$NPT" = "1" && "$NPD" = "0" ]]
			then echo -n " (no partitions)"; NPD=1
		fi
		echo
		tt__hdd_smart_status $X -q
		test -n "$S" && echo "$CWHT==== ${CYEL}SMART data  $S"
		else ZERO="$ZERO $X"
	fi

	if [ $NPT = 0 ]
		then for X in $(cat "$PART" | grep "$DRV" | tr \\n " ")
			do
			unset PARTATTR
			Y=$(echo $X | tr . " " | awk '{ print $2 }')
			Z=$(expr $Y \* 1024 / 1000000000)
			if [ "$Z" -lt "2" ]
				then Z=$(expr $Y \* 1024 / 1000000)
				Z="${Z} MB"
				else Z="${Z} GB"
			fi
			SIZE="$Z"
			# Auto-space partition size string length
			LEN=$(echo "$SIZE" | wc -c); LEN=$((8 - LEN))
			while [ $LEN -gt 0 ]; do SIZE=" $SIZE"; LEN=$((LEN - 1)); done
			unset LEN
			DEVICE=$(echo "$X" | sed 's/=.*//g')
			FSID=$(echo "$X" | sed 's/^.*=//;s/\..*//' | tr '[:upper:]' '[:lower:]')
			expand_fsid $FSID
			echo "$MOUNTED" | grep -q "$DEVICE " && PARTATTR="$PARTATTR${CYEL}[Mounted]$COFF "
			echo "$KILL" | grep -q "$(basename $DEVICE)" || echo "  $CWHT+-- $CPUR$DEVICE  $CGRN$SIZE  $CWHT$FS  $PARTATTR"
		done
	fi
done

test ! -z "$RAID" && echo
for DRV in $RAID
	do
	get_device_info $DRV
	echo "$CCYA$DRV: $CRED$MDTYPE $CGRN($DEVSIZE)  $CWHT$ATTRIBS$COFF"
	echo "  $CWHT+-- ${CGRN}Members: $CWHT$MEMBERS$COFF"
done

if [ ! -z "$ZERO" ]
	then echo -e "\n${CCYA}Empty devices: $CYEL$ZERO$COFF"
fi

echo -e "$COFF"
rm -f $PART
