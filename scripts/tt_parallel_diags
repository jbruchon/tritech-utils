#!/bin/bash

# Attempts to run parallel disk diags and burn-ins.

VER=1.0
VERDATE=2013-12-04

export FORK=0
export BURNSECS=600
shopt -s nullglob

. tss__common
. tss_client

PCDATA=/mnt/cifs/computer_data/$PCID
THRM="/sys/bus/acpi/drivers/thermal/LNXTHERM:00/thermal_zone/temp"
SEP="${CPUR}||$COFF"
WARNSOUND=/usr/share/sounds/tritech-utils/temp_warn.wav

clean_exit () {
	kill $(jobs -p) 2>/dev/null >/dev/null
	test $FORK -eq 0 && sleep 1
	wait
	#kill -9 $(jobs -p) 2>/dev/null >/dev/null
	if [ $FORK -eq 0 ]
		then rm "$BTEMP" "${DTEMP[@]}"
		test "$TSS_CLIENT" = "1" && push_actions
		tt_sysinfo
	fi
	exit
}

trap clean_exit INT TERM QUIT USR1

temp_warn () {
	test -e $WARNSOUND && aplay $WARNSOUND 2>/dev/null >/dev/null
	test -e $WARNSOUND && aplay $WARNSOUND 2>/dev/null >/dev/null
	tt_beepsong fxchirp 2>/dev/null >/dev/null
}

burnin () {
	export FORK=1
	BX="$(cat $1)"
	CPUS="$(cat /proc/cpuinfo | grep processor | grep -v model | cut -d\  -f 2 | tail -1)"
	CPUS=$((CPUS + 1))
	IDX=0
	while [ $IDX -lt $CPUS ]
		do
		nice -n 19 yes >/dev/null &
		IDX=$((IDX + 1))
	done
	while [ $BX -ne 0 ]
		do echo $BX > "$1"
		sleep 1
		BX=$((BX - 1))
	done
	echo "PASS" > "$1"
	kill $(jobs -p) 2>/dev/null
	clean_exit
}

disktest () {
	export FORK=1
	START=$(date +%s)
	if nice -n 1 pv -pterabf -i 4 -N "$2" "$2" >/dev/null 2>"$1"
		then echo "$2: PASS" > "$1"
		eval $PASS_COMMAND
		else echo "$2: FAIL" > "$1"
		eval $FAIL_COMMAND
		FAIL=1
	fi
	END=$(date +%s)
	TIME=$((END - START))
	SIZE=$(cat /sys/block/$(basename $2)/size)
	test "$TSS_CLIENT" = "1" && test -z "$FAIL" && echo "$2:$SIZE:$TIME" >> $PCDATA/drive_test_times.txt
	clean_exit
}

pv_tail () {
	cat "$1" | tr \\r \\n | tail -n 1
}

# Function names called with tempfile name, then device
test "$1" = "burnin" && burnin "$2"
test "$1" = "disktest" && disktest "$2" "$3"
test ! "$1" = "" && echo "Bad argument, aborting." && exit

test ! "$PV" = "1" && echo "${CRED}Error:$CWHT pv$COFF required but not found." && exit 2

echo "Tritech Service System parallelized diagnostics $VER ($VERDATE)"
echo "Gathering system information..."
push_sysinfo
tt_collect_comp_data

echo "Initializing..."

DI=0
BTEMP=$(mktemp)
# Set burnin time in seconds
echo $BURNSECS > $BTEMP

for X in /dev/sd? /dev/hd?
	do
	# Only diagnose non-USB, non-removable drives
	XD=$(echo $X | sed s./dev/..)
	USB=0; readlink /sys/block/$XD | grep -q "/usb" && USB=1
	REM=$(cat /sys/block/$XD/removable)
	if [[ $USB -eq 0 && $REM -eq 0 ]]
		then
		DSK[$DI]=$X
		DTEMP[$DI]=$(mktemp)
		DI=$((DI + 1))
	fi
done
"$0" burnin $BTEMP &
BSTATCACHE=600
DIC=0; DDONE=0; BDONE=0
while [ $DIC -lt $DI ]
	do
	echo 0 > "${DTEMP[DIC]}"
	"$0" disktest "${DTEMP[DIC]}" "${DSK[DIC]}" &
	DIC=$((DIC + 1))
done

sleep 2

while true
	do
	clear
	[[ $DDONE = 1 && $BDONE = 1 ]] && break
	if [ $BDONE = 0 ]
		then BSTAT="$(cat "$BTEMP")"
		if [ "$BSTAT" = "" ]
			then BSTAT=$BSTATCACHE
			else BSTATCACHE=$BSTAT
		fi
		if [ "$BSTAT" = "PASS" ]
			then BDONE=1
			echo -n "Burn-in: PASS"
			A_BURNIN=1
			else echo -n "Burn-in: ${BSTAT}sec"
		fi
		else echo -n "Burn-in: PASS"
	fi
	if [ -e $THRM ]
		then CPUTEMP="$(expr $(cat $THRM) / 1000)"
		echo -n " $SEP Temp "
		test $CPUTEMP -gt 60 && echo -n "$CYEL"
		test $CPUTEMP -gt 68 && test $CPUTEMP -lt 100 && echo -n "$CRED" && temp_warn
		test $CPUTEMP -ge 100 && echo -n "$CPUR"
		test $CPUTEMP -lt 60 && echo -n "$CGRN"
		echo -n "$CPUTEMP${CWHT} C$COFF"
	fi
	CNT=1
	for X in /sys/devices/virtual/thermal/cooling_device*
		do if [ "$(cat $X/type)" = "Fan" ]
			then
			CS="$(cat $X/cur_state)"
			MS="$(cat $X/max_state)"
			if [ $CS -eq 0 ]
				then FAN="${COFF}Off"
				else
				test $CS -eq $MS && FRAC="(max)"
				test $MS -eq 1 && unset FRAC
				test $CS -ne $MS && FRAC="($CS/$MS)"
				FAN="${CWHT}On $CBLU$FRAC$COFF"
			fi
			echo -n " $SEP Fan $CNT: $FAN"
			CNT=$((CNT+1))
		fi
	done
	echo
	if [ $DDONE = 0 ]
		then DIC=0; DFINISH=0
		while [ $DIC -lt $DI ]
			do
			DSTAT="$(pv_tail "${DTEMP[DIC]}")"
			if [ "$DSTAT" = "" ]
				then DSTAT=${DSTATCACHE[DIC]}
				else DSTATCACHE[$DIC]=DSTAT
				echo "$DSTAT" > "${DTEMP[DIC]}"
			fi
			echo "$DSTAT"
			DSTAT="$(echo "$DSTAT" | sed 's/^.*: //')"
			if [[ "$DSTAT" = "FAIL" || "$DSTAT" = "PASS" ]]
				then DFINISH=$((DFINISH + 1))
			fi
			DIC=$((DIC + 1))
		done
		test $DFINISH = $DIC && DDONE=1
		
		else
		DIC=0
		while [ $DIC -lt $DI ]
			do 
			echo "$(pv_tail "${DTEMP[DIC]}")"
			DIC=$((DIC + 1))
		done
	fi
	sleep 4
done

echo -n "Burn-in: PASS  "
DIC=0
# Retrieve HDD test results, setting failure notice if any failed
while [ $DIC -lt $DI ]
	do
	echo -n "$(pv_tail "${DTEMP[DIC]}" | sed 's./dev/..')  "
	pv_tail "${DTEMP[DIC]}" | grep -q 'FAIL' && export N_BADHDD=1
	DIC=$((DIC + 1))
done
echo

A_HDD=1

# Scan MBRs on all connected drives
for X in /dev/sd? /dev/hd?
	do
	tt_scan_mbr $(basename $X) && R=$?
	case $R in
		3) A_MBR=1; A_VIRUS=1 ;;
		2) A_MBR=1 ;;
		0) A_MBR=1 ;;
		*) ;;
	esac
	unset R

done

clean_exit
