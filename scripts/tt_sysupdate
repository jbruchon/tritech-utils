#!/bin/bash

VER=1.6.1
VERDATE="2017-08-19"

. tss__common

# Updates the system core/packages from the best source possible.

do_help () {
	echo -e "\nUsage: $(basename "$0") [-a] [-d] [-f] [-l] [-v]\n"
	echo "    -a   Don't wait for an abort keystroke"
	echo "    -d   Debugging mode (no installing done, implies -v)"
	echo "    -f   Force install packages even if same version is installed"
	echo "    -l   Local only; do not run tt_cifs before updating"
	echo "    -v   Verbose operation"
	echo
	exit
}

unpack_package () {
	FNAME="$1"
	FLIST="/packages/installed/${FNAME//*\//}"
	FLIST="${FLIST/%.pkg.tar.[a-z]*/}"
	test -e "$FLIST" && test $FORCE -eq 0 && return 2
	DECOMP="$(suggest_decompressor "$FNAME")"
	# Do not unpack existing packages unless -f is passed
	dispatch $DECOMP -dc "$FNAME" | tar -C / -xvp > $FLIST 2>/dev/null
}

dispatch () {
	test -z "$SUB" && SUB=0
	test -z "$MAXSUB" && MAXSUB=$(grep ^processor /proc/cpuinfo | tail -n 1 | sed 's/.*:\s*//') && MAXSUB=$((MAXSUB + 1))
	if [ $MAXSUB -gt 1 ]
		then
		while [ $SUB -ge $MAXSUB ]
			do sleep 0.001
			SP=$MAXSUB
			while [ $SP -gt 0 ]
				# If child process terminates, remove it.
			 	do if ! kill -0 ${SUBPID[$SP]} 2>/dev/null
					then
					DEL=$SP
					while [ $DEL -lt $SUB ]
						do
						DEL2=$((DEL + 1))
						SUBPID[$DEL]="${SUBPID[$DEL2]}"
						DEL=$DEL2
					done
					unset SUBPID[$SUB]
					SUB=$((SUB - 1))
				fi
				SP=$((SP - 1))
			done
		done
		SUB=$((SUB + 1))
		$@ &
		SUBPID[$SUB]=$!
	else $@
	fi
}

shopt -s nullglob
VP="packages"
VF="$VP/version"
PI="/packages/installed"
POST="/packages/postinst"
P=$(basename $0)
unalias ls 2>/dev/null >/dev/null

REPOVER=0

# Pull machine architecture and perform corrections
ARCH=$(uname -m | sed 's/_/-/g')
test "$ARCH" = "i686" && ARCH="i386"
test "$ARCH" = "i586" && ARCH="i386"
test "$ARCH" = "i486" && ARCH="i386"

# Set flags for verbose, debug, etc.
V=0; DBG=0; ABRT=1; FORCE=0; LOCAL=0; MOUNT=1
for X in $@
	do case "$X" in
		"-a") ABRT=0 ;;
		"-d") DBG=1; V=1 ;;
		"-l") LOCAL=1 ;;
		"-f") FORCE=1 ;;
		"-v") V=1 ;;
		   *) do_help ;;
	esac
done

echo "${CWHT}Tritech Service System updater $CGRN$VER $CCYA($VERDATE)$COFF"

if [ "$BASH" = "" ]
	then test -e /bin/bash && exec bash $0
	echo "$CRED$P$COFF must be run under GNU bash (/bin/bash)."
	exit 1
fi

echo "$@" | grep -q -e '-h' -e '--help' && do_help

# Allow an interactive user abort unless otherwise specified
if [ "$ABRT" = "1" ]
	then
	echo "${CYEL}Press a key to abort updating.$COFF"
	read -t 2 -s -n 1 && \
		echo "${CYEL}User aborted update, terminating.$COFF" && \
		exit 1
fi

test ! -d /packages/installed && mkdir -p /packages/installed 2>/dev/null

try_using_cifs () {
# CIFS repository
Z=0
CIFS=0
echo -n "Trying CIFS: "
if tt_cifs -c
	then Y=/mnt/cifs ; Z="/mnt/cifs/$VF"; mkdir -p $Y 2>/dev/null
	test "$V" = "1" && echo "CIFS=$CIFS with path $Z"
fi
}

test $LOCAL -eq 0 && try_using_cifs

# We rely on fstab being set up properly as of version 0.4

# Allow user to skip mounting sources
# This is handy e.g. if a hard drive is failing
echo "${CYEL}Press a key to skip mount scanning.$COFF"
test $ABRT -eq 1 && read -t 2 -s -n 1 && MOUNT=0 && \
	echo "${CRED}Mounting has been disabled.$COFF"

# Mount and scan for repositories
test "$V" = "0" && echo -n "Scanning repositories: "
for Y in /mnt/*
	do Z="$Y/$VF"
	test "$V" = "1" && echo "Trying mountpoint $Y"
	M=0; cat /proc/mounts | cut -d" " -f2 | grep -q "$Y" \
		&& M=1 && test "$V" = "1" && echo "$Y already mounted"
	MOK=0
	test $MOUNT -eq 1 && \
		/bin/mount "$Y" -o ro >/dev/null 2>/dev/null && MOK=1
	if [ "$V" = "1" ]
		then test "$MOK" = "1" && echo "$Y mounted."
		test ! "$MOK" = "1" && echo "$Y mount failed."
	fi
	if [ -e "$Z" ]
		then TV=$(cat $Z)
		if [ "$V" = "1" ]
			then echo "found repo version $CGRN$TV$COFF on $CWHT$Y$COFF"
			else echo -n "$CWHT$(basename $Y)$COFF "
		fi
		if [ "$TV" -gt "$REPOVER" ]
			then REPOVER=$TV; UPDY=$Y; UPDPATH="$Y/$VP"; CIFS=0
			test "$V" = "1" && echo "RV $REPOVER at $CGRN$UPDPATH$COFF higher!"
			else test "$V" = "1" && echo "RV $TV not higher than $REPOVER, skipping."
		fi
		else test "$V" = "1" && echo "$CRED$Z$COFF does not seem to exist."
	fi
	test "$M" = "0" && umount $Y >/dev/null 2>/dev/null
done
echo

if [ "$REPOVER" = "0" ]
	then echo "No update repositories found, not updating."
	exit 1
fi

if [ "$CIFS" = "0" ]
	then MTD=0
	grep -qv "$UPDY" /proc/mounts && mount $UPDY -o ro >/dev/null 2>/dev/null && MTD=1
fi

# Start processing the package repository
I=0; USE=0; J=0; GOOD=0
echo "Chose repository $CCYA$(basename "$UPDY")$COFF"

# Self-update check
UPDATE=0
if [ -e $UPDPATH/$P ]
	then SUV=$(grep -m 1 'VER=' < $UPDPATH/$P | sed 's/VER=//g' | tr -d \\n)
	SUVH=$(echo $SUV | cut -d. -f1); VERH=$(echo $VER | cut -d. -f1)
	test $SUVH -gt $VERH && UPDATE=1
	if [ $SUVH = $VERH ]
		then SUVL=$(echo $SUV | cut -d. -f2); VERL=$(echo $VER | cut -d. -f2)
		test $SUVL -gt $VERL && UPDATE=1
		if [ $SUVL = $VERL ]
			then SUVR=$(echo $SUV | cut -d. -f3); VERR=$(echo $VER | cut -d. -f3)
			test -z "$SUVR" && SUVR=0
			test -z "$VERR" && VERR=0
			test $SUVR -gt $VERR && UPDATE=1
		fi
	fi
	if [ $UPDATE = 1 ]
		then echo "Newer update script in repository. Performing self-update."
		ERR=0
		NEW="/tmp/$P"
		cp $UPDPATH/$P $NEW || ERR=1
		chmod 700 $NEW || ERR=1
		chown root:root $NEW || ERR=1
		test "$MTD" = "1" && umount $UPDY 2>/dev/null
		if [ "$ERR" = "0" ]
			then
			$NEW "$@"
			exit

			else
			echo "Self-update failed, continuing as normal."
		fi
	fi
fi

for X in ${UPDPATH}/*.pkglist
		do X=$(basename "$X" | sed s/.pkglist//g)
		test "$V" = "1" && echo "Adding $CYEL$X$COFF"
		cnf[I]="$X"; I=$((I + 1)); GOOD=1
done
if [ "$I" -gt "1" ]
	then echo -e "Multiple configurations available, please select one.\n"
	while [ $J -lt $I ]
		do echo "$CWHT$J:$COFF ${cnf[$J]}"
		J=$((J + 1))
	done
	echo -en "\nEnter choice (10s timer, default 0, \"n\" to cancel): "
	X=0; read -t 10 X || echo
	if [ "$X" = "n" ]
		then echo "User canceled update process."
		exit 1
	fi
	X=$(echo $X | sed 's/[^0-9]//g')
	if [[ $X -lt 0 || $X -gt $I ]]
		then USE=0
		else USE=$X
	fi
fi

echo "${cnf[$USE]}" | grep -q '*' && echo "${CRED}No configurations present in this repository.$COFF" && exit 1

test "$GOOD" = "0" && echo "${CRED}No usable configurations in this repository.$COFF" && exit 1

echo -en "Selected $CCYA${cnf[$USE]}$COFF, "
UP="$UPDPATH/${cnf[$USE]}"

echo -n "Unpacking packages: "

cd "$UPDPATH"

for X in $(cat ${UP}.pkglist)
	do Y="none"
	# Handle multiple package types available if required
	for ARCHPKG in all/${X}_*.pkg.tar.{lzo,gz,bz2,xz,lzma} $ARCH/${X}_*.pkg.tar.{lzo,gz,bz2,xz,lzma}
		do W="__NONE__"
		test -e "$ARCHPKG" && W="$ARCHPKG"
		test "$W" = "__NONE__" && test -e "$ALLPKG" && W="$ALLPKG"
		if [ -e "$W" ]
			then Y="$W"
			test "$V" = "1" && echo -n "$CBLU$Y$COFF "
			break
		fi
	done
	if [ "$Y" = "none" ]
		then echo -n " $CRED$X$COFF "
		else
		test "$DBG" = "0" && unpack_package "$Y"
		test $? = 2 && echo -n "$CYEL" || echo -n "$CGRN"
		echo -n ".$COFF"
	fi
done

wait ${SUBPID[@]}

echo
cd /
test "$V" = "1" && echo "Done working; unmounting package source."
test "$MTD" = "1" && umount $UPDY

# Run post-install scripts
if [ -d "$POST" ]
	then
	for S in $POST/*
		do $S
		rm -f $S
	done
fi

