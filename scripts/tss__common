#!/bin/sh

TSS_COMMON_VER=1.0.1
TSS_COMMON_VERDATE=2017-08-31

# Prevent loading if we are already loaded
if [ -z "$TSS_COMMON" ]; then

# Scripts can check for TSS_COMMON to ensure this file is loaded
TSS_COMMON=1

N=__NONE__


### Get version details of GNU bash
BASH_VERSION=0; BASH_MAJOR=0; BASH_MINOR=0
if [ -x "$BASH" ]
	then
	BASH_MAJOR="$($BASH -c 'echo ${BASH_VERSINFO[0]}')"
	BASH_MINOR="$($BASH -c 'echo ${BASH_VERSINFO[1]}')"
fi

### Command for retrieving seconds since epoch
# External 'date' command
date 2>/dev/null >/dev/null && GET_EPOCH_SECS="date +%s"
# Bash 4.2 and up supports a faster builtin 'printf' version
if [ $BASH_MAJOR -ge 4 ]
	then if [[ $BASH_MAJOR -gt 4 || $BASH_MINOR -gt 2 ]]
		then GET_EPOCH_SECS="printf '%(%s)T\n' -1"
	fi
fi


### Sources for CPU temperature, from worst to best

export THERMAL_SOURCES="
	/sys/class/hwmon/hwmon0/device/temp2_input
	/sys/class/hwmon/hwmon0/temp1_input
	/sys/class/hwmon/hwmon1/temp1_input
	/sys/class/hwmon/hwmon0/temp3_input
	/sys/class/hwmon/hwmon1/temp3_input
	/sys/bus/acpi/drivers/thermal/LNXTHERM:00/thermal_zone/temp
	/sys/devices/platform/coretemp.*/temp*_input
	/sys/bus/pci/drivers/k*temp/*:*/temp1_input
	/sys/class/thermal/thermal_zone0/temp
	/sys/bus/platform/devices/coretemp.0/hwmon/hwmon0/temp2_input
	/sys/bus/platform/devices/coretemp.0/hwmon/hwmon0/temp4_input
	/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp2_input
"

### End thermal sources

### tt__alert_setup

# See if the requirements for beepsong usage are met
# Longest. Statement. Ever.
export PASS_COMMAND='tt_beepsong ff7victory'
export FAIL_COMMAND='tt_beepsong taps'

### End alert setup

### tt__color_setup

# ANSI color codes

export COFF="$(echo -e '\e[00m')"    # Disable all attributes
export CBLINK="$(echo -e '\e[05m')"  # Annoying Blink

# Foreground colors
export CBLK="$(echo -e '\e[01;30m')" # Black
export CRED="$(echo -e '\e[01;31m')" # Red
export CGRN="$(echo -e '\e[01;32m')" # Green
export CYEL="$(echo -e '\e[01;33m')" # Yellow
export CBLU="$(echo -e '\e[01;34m')" # Blue
export CPUR="$(echo -e '\e[01;35m')" # Purple (Magenta)
export CCYA="$(echo -e '\e[01;36m')" # Cyan
export CWHT="$(echo -e '\e[01;37m')" # White

# Background colors
export BGBLK="$(echo -e '\e[01;40m')" # Black
export BGRED="$(echo -e '\e[01;41m')" # Red
export BGGRN="$(echo -e '\e[01;42m')" # Green
export BGYEL="$(echo -e '\e[01;43m')" # Yellow
export BGBLU="$(echo -e '\e[01;44m')" # Blue
export BGPUR="$(echo -e '\e[01;45m')" # Purple (Magenta)
export BGCYA="$(echo -e '\e[01;46m')" # Cyan
export BGWHT="$(echo -e '\e[01;47m')" # White

### End color setup

STARTDIR="$(pwd)"
test -z "$BASE" && BASE=/mnt/cifs
test -z "$SOURCE" && SOURCE="$BASE/source"
test -z "$IMGDIR" && IMGDIR="$SOURCE/hd_images"
test -z "$HALPATH" && HALPATH="$SOURCE/hal"

export MS="Microsoft"
export WIN="Windows"
export IE="Internet Explorer"

export XPDOCS="Documents and Settings"
export V7DOCS="Users"
export PD="ProgramData"
export PF="Program Files"
export VS="VirtualStore"
export XPLS="Local Settings"
export XPLOCAL="$XPLS/Application Data"
export V7LOCAL="AppData/Local"
export XPROAM="Application Data"
export V7ROAM="AppData/Roaming"
export XPALL="$XPDOCS/All Users"
export V7ALL="$V7DOCS/Public"
export TIF="Temporary Internet Files"

tt__read_memory_size () {
	# Read DMI memory size and decide if MB or GB is more appropriate.
	# The calculations make MEMT reporting more friendly, i.e. 1280 MB -> "1.25GB"
	if dmidecode -t memory 2>/dev/null | grep -v 'kB' | grep -v 'No Module' | grep -q '^\sSize: '
		then
		for X in $(dmidecode -t memory 2>/dev/null | grep -v 'kB' | grep -v 'No Module' | grep '^\sSize: ' | cut -d: -f2 | cut -d\  -f2)
			do MEMT=$((MEMT + X))
		done
		else
		MEMT=$(cat /proc/meminfo | grep 'MemTotal:' | awk '{print $2}')
		MEMT=$(($MEMT + 11000))
		MEMT=$(expr $MEMT / 1024)
	fi
	if [ $MEMT -lt 1024 ]
		then RAM="${MEMT}MB"
		else RAM="$(expr $MEMT / 1024).$(expr $MEMT % 1024 \* 100 / 1024)GB"
	fi
}

do_windows_folder_detection () {
	# Set variables that are used for folder detection
	export WINDIR=$N
	export WINTEMP=$N
	export SYS32=$N
	export SYS64=$N
	export CONFIG=$N
	export OS_CLASS=$N
	export V7=0
	export HALDLL=$N
	export KERNEL=$N
	export REG_SAM=$N
	export REG_SW=$N
	export REG_SYS=$N

	for X in WINDOWS Windows windows WINXP WinXP winxp WINNT WinNT winnt
		do test -d $X && export WINDIR=$X; done

	for X in $WINDIR/Temp $WINDIR/TEMP $WINDIR/temp
		do test -d $X && export WINTEMP=$X; done

	for X in system32 System32 SYSTEM32
		do test -d $WINDIR/$X && export SYS32=$X; done

	for X in syswow64 SysWOW64 SYSWOW64
		do test -d $WINDIR/$X && export SYS64=$X; done

	for X in config Config CONFIG
		do test -d $WINDIR/$SYS32/$X && export CONFIG=$X; done

	for X in sam Sam SAM
		do test -e $WINDIR/$SYS32/$CONFIG/$X && export REG_SAM=$X; done

	for X in software Software SOFTWARE
		do test -e $WINDIR/$SYS32/$CONFIG/$X && export REG_SW=$X; done

	for X in system System SYSTEM
		do test -e $WINDIR/$SYS32/$CONFIG/$X && export REG_SYS=$X; done

	for X in systemprofile SYSTEMPROFILE SystemProfile
		do test -d $WINDIR/$SYS32/$CONFIG/$X && export SYSPROF=$X; done

	for X in HAL.DLL hal.dll Hal.dll hal.DLL HAL.dll
		do test -e $WINDIR/$SYS32/$X && export HALDLL=$X; done

	for X in ntoskrnl.exe NTOSKRNL.EXE ntoskrnl.EXE NTOSKRNL.exe
		do test -e $WINDIR/$SYS32/$X && export KERNEL=$X; done

	# Scan for 2000/XP or Vista/7
	test -d "$XPDOCS" && OS_CLASS="2000/XP" && export V7=1
	test -d "$V7DOCS" && OS_CLASS="Vista/7" && export V7=2

	# Handle different OS folder choices
	if [ "$V7" = "2" ]
		then
			export P="$V7DOCS/*"
			export LOCAL="$P/$V7LOCAL"
			export ROAM="$P/$V7ROAM"
		else
			export P="$XPDOCS/*"
			export LOCAL="$P/$XPLOCAL"
			export ROAM="$P/$XPROAM"
	fi

	# Use a progress bar version of "cat" if available
	export CATCOM=cat
	pv --version 2>/dev/null >/dev/null &&
		export CATCOM='pv -pterab' && export PV=1

	# Find an NTFS mount command
	export NTFSMOUNT=0
	for X in /bin/ntfs-3g /sbin/ntfs-3g /sbin/mount.ntfs-3g \
		/sbin/mount.ntfs /usr/bin/ntfs-3g /usr/sbin/ntfs-3g /usr/bin/ntfsmount
		do if [ "$NTFSMOUNT" = "0" ]
			then test -e "$X" && export NTFSMOUNT="$X"
		fi
	done
}

do_windows_folder_detection

tt__hdd_smart_status () {
	SMART_SED='s/ ([^)]*)$//;s/([^)]*)$//;s/.* //g;s/[^0-9].*//'
	if smartctl -V >/dev/null 2>/dev/null
		then
		unset S LCC RSC UNC REC CPS OUNC UCEC
		SELE=1
		# Check for existence of SMART error log entries
		smartctl -l error /dev/$1 | grep -q '[Nn]o [Ee]rrors [Ll]ogged' && SELE=0
		test "$SELE" = "1" && smartctl -d sat -l error /dev/$1 | grep -q '[Nn]o [Ee]rrors [Ll]ogged' && SELE=0
		test "$SELE" = "1" && S="${CYEL}SELE$COFF"
		# Fetch SMART stats into variables
		SMART_TEMP=$(mktemp)
		smartctl -A /dev/$1 > $SMART_TEMP
		LCC=$(grep -m 1 Load_Cycle_Count $SMART_TEMP | sed "$SMART_SED")
		RSC=$(grep -m 1 Reallocated_Sector_Ct $SMART_TEMP | sed "$SMART_SED")
		UNC=$(grep -m 1 Reported_Uncorrect $SMART_TEMP | sed "$SMART_SED")
		REC=$(grep -m 1 Reallocated_Event_Count $SMART_TEMP | sed "$SMART_SED")
		CPS=$(grep -m 1 Current_Pending_Sector $SMART_TEMP | sed "$SMART_SED")
		OUNC=$(grep -m 1 Offline_Uncorrectable $SMART_TEMP | sed "$SMART_SED")
		UCEC=$(grep -m 1 UDMA_CRC_Error_Count $SMART_TEMP | sed "$SMART_SED")
		PFC=$(grep -m 1 ^171 $SMART_TEMP | sed "$SMART_SED")
		EFC=$(grep -m 1 ^172 $SMART_TEMP | sed "$SMART_SED")
		# Add color indicators to stats
		if [ -n "$LCC" ]
			then
			test $LCC -lt 200000 && S="$S ${CGRN}LCC=$LCC$COFF"
			test $LCC -ge 200000 && S="$S ${CYEL}LCC=$LCC$COFF"
			test $LCC -ge 300000 && test $LCC -lt 1000000 && S="$S ${CRED}LCC=$LCC$COFF"
		fi
		if [ -n "$RSC" ]
			then
			test $RSC -gt 0 && test $RSC -lt 100 && S="$S ${CYEL}RSC=$RSC$COFF"
			test $RSC -ge 100 && test $RSC -lt 100000 && S="$S ${CRED}RSC=$RSC$COFF"
		fi
		test -n "$UNC" && test $UNC -gt 0 && test $UNC -ne 65536 && test $UNC -lt 500000 && S="$S  ${CRED}UNC=$UNC$COFF"
		if [ -n "$REC" ]
			then
			test $REC -gt 0 && test $REC -lt 10 && S="$S ${CYEL}REC=$REC$COFF"
			test $REC -ge 10 && test $REC -lt 10000 && S="$S ${CRED}REC=$REC$COFF"
		fi
		if [ -n "$CPS" ]
			then
			test $CPS -gt 0 && test $CPS -lt 10 && S="$S ${CYEL}CPS=$CPS$COFF"
			test $CPS -ge 10 && test $CPS -lt 10000 && S="$S ${CRED}CPS=$CPS$COFF"
		fi
		if [ -n "$OUNC" ]
			then
			test $OUNC -gt 0 && test $OUNC -lt 10 && S="$S ${CYEL}OUNC=$OUNC$COFF"
			test $OUNC -ge 10 && test $OUNC -lt 10000 && S="$S ${CRED}OUNC=$OUNC$COFF"
		fi
		if [ -n "$UCEC" ]
			then
			test $UCEC -gt 0 && test $UCEC -lt 2000 && S="$S ${CYEL}UCEC=$UCEC$COFF"
			test $UCEC -ge 2000 && test $UCEC -lt 10000 && S="$S ${CRED}UCEC=$UCEC$COFF"
		fi
		if [ -n "$PFC" ]
			then
			test $PFC -gt 0 && test $PFC -lt 10 && S="$S ${CYEL}PFC=$PFC$COFF"
			test $PFC -ge 10 && test $PFC -lt 10000 && S="$S ${CRED}PFC=$PFC$COFF"
		fi
		if [ -n "$EFC" ]
			then
			test $EFC -gt 0 && test $EFC -lt 10 && S="$S ${CYEL}EFC=$EFC$COFF"
			test $EFC -ge 10 && test $EFC -lt 10000 && S="$S ${CRED}EFC=$EFC$COFF"
		fi
		# Display final stats
		test "$2" != "-q" && test -n "$S" && echo "$CWHT$1$COFF:     $CWHT+-- ${CCYA}SMART:$S"
		rm -f $SMART_TEMP
	fi
}

# Close double loading protection
fi
